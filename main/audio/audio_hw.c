#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2s_std.h"
#include "driver/gpio.h"

#include "audio_hw.h"
#include "gpio_config.h"

static i2s_chan_handle_t tx_handle;

static float s_notes_freq[NOTE_MAX][OCTAVE_MAX] = {
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {32.70, 65.41, 130.81, 261.63, 523.25, 1046.50, 2093.00, 4186.01},
    {34.65, 69.30, 138.59, 277.18, 554.37, 1108.73, 2217.46, 4434.92},
    {36.71, 73.42, 146.83, 293.66, 587.33, 1174.66, 2349.32, 4698.63},
    {38.89, 77.78, 155.56, 311.13, 622.25, 1244.51, 2489.02, 4978.03},
    {41.20, 82.41, 164.81, 329.63, 659.25, 1318.51, 2637.02, 5274.04},
    {43.65, 87.31, 174.61, 349.23, 698.46, 1396.91, 2793.83, 5587.65},
    {46.25, 92.50, 185.00, 369.99, 739.99, 1479.98, 2959.96, 5919.91},
    {49.00, 98.00, 196.00, 392.00, 783.99, 1567.98, 3135.96, 6271.93},
    {51.91, 103.83, 207.65, 415.30, 830.61, 1661.22, 3322.44, 6644.88},
    {55.00, 110.00, 220.00, 440.00, 880.00, 1760.00, 3520.00, 7040.00},
    {58.27, 116.54, 233.08, 466.16, 932.33, 1864.66, 3729.31, 7458.62},
    {61.74, 123.47, 246.94, 493.88, 987.77, 1975.53, 3951.07, 7902.13}
};
int16_t sending_buffer[SAMPLES_BUFFER_SIZE];
float s_buffer[SAMPLES_BUFFER_SIZE];


void play(float freq)
{
    float d_time = 0.0;
    float d_time_step = 1.0 / 44100;

    esp_err_t err;
    size_t sent_data_size = 0;

    for(int i = 0; i < SAMPLES_BUFFER_SIZE; i+=2)
    {
        s_buffer[i] =  sinf(freq * PI2 * d_time); 
        s_buffer[i+1] =  sinf(freq * PI2 * d_time); 
        d_time += d_time_step;
        if( d_time * freq * PI2 / 44100 > PI2)
        {
            d_time = 0;
        }
    }
    audio_send(s_buffer);

}


float * get_buffer()
{
    return s_buffer;
}

void audio_send(float * buffer)
{
    esp_err_t err;
    size_t sent_data_size = 0;

    for(int i = 0; i < SAMPLES_BUFFER_SIZE; i++)
    {
        buffer[i] *= 255;
        sending_buffer[i] = (int16_t)buffer[i]; 
    }

    err = i2s_channel_write(tx_handle, sending_buffer, sizeof(int16_t) * SAMPLES_BUFFER_SIZE , &sent_data_size, 1000);
}

void i2s_init()
{
    i2s_chan_config_t chan_cfg =
    {
        .auto_clear = false,
        .dma_desc_num = 6,
        .dma_frame_num = DMA_FRAME_NUM,
        .id = I2S_NUM_0,
        .role = I2S_ROLE_MASTER
    };
    /* Allocate a new tx channel and get the handle of this channel */
    i2s_new_channel(&chan_cfg, &tx_handle, NULL);
    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
    * They can help to specify the slot and clock configurations for initialization or updating */
    i2s_std_config_t std_cfg = {
        .clk_cfg = 
        {
            .clk_src = I2S_CLK_SRC_DEFAULT,
            .mclk_multiple = I2S_MCLK_MULTIPLE_256,
            .sample_rate_hz = SAMPLE_RATE,
        },
        .slot_cfg = 
        {
            .bit_shift = false,
            .data_bit_width = I2S_DATA_BIT_WIDTH_16BIT,
            .slot_bit_width = I2S_SLOT_BIT_WIDTH_16BIT,
            .slot_mask = I2S_STD_SLOT_BOTH,
            .slot_mode = I2S_SLOT_MODE_STEREO,
            .ws_pol = false,
            .ws_width = I2S_DATA_BIT_WIDTH_16BIT,
        },
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = I2S_OUT_BCLK,
            .ws = I2S_OUT_WS,
            .dout = I2S_OUT_DO,
            .din = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };

    i2s_channel_init_std_mode(tx_handle, &std_cfg);
    i2s_channel_enable(tx_handle);
}


float get_note_freq(audio_note_e note, audio_octaves_e octave)
{
    return s_notes_freq[note][octave];
}

