#include <stdint.h>
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <math.h>
#include "driver/i2s_std.h"
#include "driver/gpio.h"

#include "system_message.h"
#include "audio_module.h"
#include "audio_config.h"
#include "gpio_config.h"
#include "common.h"

#define PI               (3.14159265)
#define PI2              (6.28318530)
#define PIH              (0.63661977)

#define AMOUNT_OF_CHANNELS 2
#define SAMPLE_SIZE 2 // size of one sample for 16 bit data
#define DMA_FRAME_NUM 256 // Amount of data for one WS Click (basically one channel)
#define SAMPLES_BUFFER_SIZE (AMOUNT_OF_CHANNELS * DMA_FRAME_NUM) // size of one data buffer, which should has two channels's data

static i2s_chan_handle_t tx_handle;

static void i2s_init();

typedef enum {
    OSC_SINE,
    OSC_SQUARE,
    OSC_TRIANGLE,
    OSC_SAW,
    OSC_NOISE
}osc_types_e;

float w(float freq_hz)
{
    return freq_hz * PI2;
}

float osc(osc_types_e osc_type, float note_hz, float d_time, float lfo_freq, float lfo_amp)
{
    float freq = w(note_hz) * d_time + lfo_amp * note_hz * (sinf(w(lfo_freq) * d_time));
    switch(osc_type)
    {
        case OSC_SINE: // Sine wave between -1 and +1
            return sinf(freq);

        case OSC_SQUARE: // Square wave between -1 and +1
            return sinf(freq) > 0 ? 1.0 : -1.0;

        case OSC_TRIANGLE: // Triangle wave between -1 and +1
            return asin(sinf(freq)) * PIH;

        case OSC_SAW:
            return PIH * (note_hz * PI * fmod(d_time, 1.0 / note_hz) - PIH);

        default:
            return 0.0;
    }
}

float envelope(float d_time)
{
    return 0.9f;
}

float calc_data(float note_hz, float d_time)
{
    float output_freq = envelope(d_time) * (
            (
            1.0 * osc(OSC_SINE, note_hz, d_time, 0, 0)
            //+ 0.5 * osc(OSC_SQUARE, note_hz * 2, d_time, 0, 0)
            //+ 0.25 * osc(OSC_SINE, note_hz * 3, d_time, 0, 0)
            ));

    return output_freq;
}

void play(float freq_hz)
{
    int16_t data_block[SAMPLES_BUFFER_SIZE];
    float d_time_step = 1.0 / SAMPLE_RATE;
    float d_time = 0;
    size_t sent_data_size = 0;
    float sample = 0;
    esp_err_t err;

    for(int i = 0; i < SAMPLES_BUFFER_SIZE; i+= AMOUNT_OF_CHANNELS)
    {
        sample = calc_data(freq_hz, d_time);
        sample *= 16383;
        data_block[i] =  (int16_t)sample;
        data_block[i+1] = (int16_t)sample;
        d_time += d_time_step;
        if( d_time * w(freq_hz) / 44100 > PI2)
        {
            d_time = 0;
        }

    }
    err = i2s_channel_write(tx_handle, data_block, sizeof(int16_t) * SAMPLES_BUFFER_SIZE , &sent_data_size, 1000);
}

void i2s_init()
{
    //i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
    i2s_chan_config_t chan_cfg =
    {
        .auto_clear = false,
        .dma_desc_num = 6,
        .dma_frame_num = DMA_FRAME_NUM,
        .id = I2S_NUM_0,
        .role = I2S_ROLE_MASTER
    };
    /* Allocate a new tx channel and get the handle of this channel */
    i2s_new_channel(&chan_cfg, &tx_handle, NULL);
    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
    * They can help to specify the slot and clock configurations for initialization or updating */
    i2s_std_config_t std_cfg = {
        .clk_cfg = 
        {
            .clk_src = I2S_CLK_SRC_DEFAULT,
            .mclk_multiple = I2S_MCLK_MULTIPLE_256,
            .sample_rate_hz = SAMPLE_RATE,
        },
        .slot_cfg = 
        {
            .bit_shift = false,
            .data_bit_width = I2S_DATA_BIT_WIDTH_16BIT,
            .slot_bit_width = I2S_SLOT_BIT_WIDTH_16BIT,
            .slot_mask = I2S_STD_SLOT_BOTH,
            .slot_mode = I2S_SLOT_MODE_STEREO,
            .ws_pol = false,
            .ws_width = I2S_DATA_BIT_WIDTH_16BIT,
        },
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = I2S_OUT_BCLK,
            .ws = I2S_OUT_WS,
            .dout = I2S_OUT_DO,
            .din = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };

    i2s_channel_init_std_mode(tx_handle, &std_cfg);
    i2s_channel_enable(tx_handle);
}


void xAudioTask(void * task_parameter)
{
    sys_msg_op_code_e op_code;
    int cur_note = 0;
    uint8_t is_play = 0;
    float freq_array[6] = 
    {
        220.0,
        329.63,
        440.0,
        523.25,
        659.25,
        880.00
    };


    i2s_init();

    while (1) {
        vTaskDelay(1/portTICK_PERIOD_MS);
    }

}
