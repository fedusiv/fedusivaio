/* I2S Example

    This example code will output 100Hz sine wave and triangle wave to 2-channel of I2S driver
    Every 5 seconds, it will change bits_per_sample [16, 24, 32] for i2s data

    This example code is in the Public Domain (or CC0 licensed, at your option.)

    Unless required by applicable law or agreed to in writing, this
    software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied.
*/
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <math.h>
#include "driver/i2s_std.h"
#include "driver/gpio.h"

#include "audio_module.h"
#include "audio_config.h"
#include "gpio_config.h"

#define PI               (3.14159265)
#define PI2              (6.28318530)
#define PIH              (0.63661977)

#define AMOUNT_OF_CHANNELS 2
#define SAMPLES_BLOCK_SIZE 48
#define SAMPLES_DATA_SIZE (AMOUNT_OF_CHANNELS * SAMPLES_BLOCK_SIZE)
#define I2C_CONVERT 2147483647

static i2s_chan_handle_t tx_handle;

static void i2s_init();

typedef enum {
    OSC_SINE,
    OSC_SQUARE,
    OSC_TRIANGLE,
    OSC_SAW,
    OSC_NOISE
}osc_types_e;

float w(float freq_hz)
{
    return freq_hz * PI2;
}

float osc(osc_types_e osc_type, float note_hz, float d_time, float lfo_freq, float lfo_amp)
{
    float freq = w(note_hz) * d_time + lfo_amp * note_hz * (sinf(w(lfo_freq) * d_time));
    switch(osc_type)
    {
        case OSC_SINE: // Sine wave between -1 and +1
            return sinf(freq);

        case OSC_SQUARE: // Square wave between -1 and +1
            return sinf(freq) > 0 ? 1.0 : -1.0;

        case OSC_TRIANGLE: // Triangle wave between -1 and +1
            return asin(sinf(freq)) * PIH;

        case OSC_SAW:
            return PIH * (note_hz * PI * fmod(d_time, 1.0 / note_hz) - PIH);

        default:
            return 0.0;
    }
}

float envelope(float d_time)
{
    return 0.5f;
}

float calc_data(float note_hz, float d_time)
{
    float output_freq = envelope(d_time) * (
            (
            1.0 * osc(OSC_SINE, note_hz, d_time, 5, 0.01)
            + 0.5 * osc(OSC_SQUARE, note_hz * 2, d_time, 0, 0)
            //+ 0.25 * osc(OSC_SINE, note_hz * 3, d_time, 0, 0)
            ) );

    return output_freq;
}

void play(float freq_hz)
{
    uint16_t data_block[SAMPLES_DATA_SIZE];
    float d_time_step = 1.0 / SAMPLE_RATE;
    float d_time = 0;
    size_t sent_data_size = 0;
    float sample = 0;
    esp_err_t err;

    for(int i = 0; i < SAMPLES_DATA_SIZE; i+= AMOUNT_OF_CHANNELS)
    {
        sample = calc_data(freq_hz, d_time);
        //sample *= 32767;
        sample *= 255;
        data_block[i] =  (short)sample;//((int)sample << 8);
        data_block[i+1] = (short)sample;//((int)sample << 8);
        d_time += d_time_step;
    }
    // float p = 0.0f;
    // float phase = w(freq_hz) / SAMPLE_RATE;
    // for(int i = 0; i < SAMPLES_DATA_SIZE; i+= AMOUNT_OF_CHANNELS)
    // {
    //     //float sample = (sinf(d_time * w(440) / SAMPLE_RATE ) + 1.0f) * 0.1f;
    //     // float freq = w(880) * d_time;
    //     // float sample = (sinf(freq) + 1.0f) * 0.1f;
    //     float sample = (sinf(p) + 1.0f) * 0.1f;
    //     p+= phase;
    //     if (p >= PI2)
    //         p -= PI2;
    //     d_time+= d_time_step;
    //     sample *= 32767;
    //     data_block[i] = (short)sample;
    //     data_block[i+1] = (short)sample;
    // }

    err = i2s_channel_write(tx_handle, data_block, sizeof(short) * SAMPLES_DATA_SIZE, &sent_data_size, 1000);
}

void i2s_init()
{
    //i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
    i2s_chan_config_t chan_cfg =
    {
        .auto_clear = false,
        .dma_desc_num = 2,
        .dma_frame_num = SAMPLES_DATA_SIZE,
        .id = I2S_NUM_0,
        .role = I2S_ROLE_MASTER
    };
    /* Allocate a new tx channel and get the handle of this channel */
    i2s_new_channel(&chan_cfg, &tx_handle, NULL);
    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
    * They can help to specify the slot and clock configurations for initialization or updating */
    i2s_std_config_t std_cfg = {
        .clk_cfg = 
        {
            .clk_src = I2S_CLK_SRC_DEFAULT,
            .mclk_multiple = I2S_MCLK_MULTIPLE_256,
            .sample_rate_hz = SAMPLE_RATE,
        },
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = I2S_OUT_BCLK,
            .ws = I2S_OUT_WS,
            .dout = I2S_OUT_DO,
            .din = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };

    i2s_channel_init_std_mode(tx_handle, &std_cfg);
    i2s_channel_enable(tx_handle);
}


void xAudioTask(void * task_parameter)
{
    gpio_set_direction(GPIO_NUM_34, GPIO_MODE_INPUT);
    int counter = 0;
    uint8_t pressed_counter = 0;
    i2s_init();
    while (1) {
        int level = gpio_get_level(GPIO_NUM_34);
        if(level == 1)
        {
            counter++;
            if(counter > 5)
            {
                counter = 0;
                pressed_counter++;
                printf("Button pressed %d!\n", pressed_counter);
                if(pressed_counter > 127)
                {
                    play(880);
                }
                else
                {
                    play(220);
                }
            }
        }
        else
        {
            counter = 0;
            play(0);
        }
        vTaskDelay(1/portTICK_PERIOD_MS);
    }

}
